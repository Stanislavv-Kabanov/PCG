<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>3D Буква 'К' - Local Coordinates</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #121212;
            color: #e0e0e0;
            padding: 20px;
        }

        h1 {
            color: #ffffff;
            border-bottom: 2px solid #ff9800;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .canvas-container {
            background-color: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            text-align: center;
            position: relative;
        }

        canvas {
            background-color: #000000;
            border-radius: 4px;
            cursor: crosshair;
        }

        .controls-matrix {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 840px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            padding: 20px;
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
            font-size: 0.9em;
            color: #bbbbbb;
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        #resetButton {
            padding: 12px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            background-color: #ff9800;
            color: #000;
            border: none;
            border-radius: 5px;
            grid-column: 1 / -1;
            transition: background-color 0.2s;
        }
        #resetButton:hover {
            background-color: #ffa726;
        }

        #matrix-display {
            font-family: 'Courier New', Courier, monospace;
            white-space: pre;
            background-color: #1e1e1e;
            color: #e0e0e0;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            line-height: 1.6;
            font-size: 0.9em;
            overflow-x: auto;
        }

        h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #cccccc;
        }
    </style>
</head>
<body>

<h1>Интерактивная 3D Модель Буквы 'К'</h1>

<div class="canvas-grid">
    <div class="canvas-container">
        <h4>3D Модель (Локальные оси)</h4>
        <canvas id="mainCanvas" width="400" height="400"></canvas>
    </div>
    <div class="canvas-container">
        <h4>Проекция на XY (Вид спереди)</h4>
        <canvas id="projectionCanvasXY" width="400" height="400"></canvas>
    </div>
    <div class="canvas-container">
        <h4>Проекция на XZ (Вид сверху)</h4>
        <canvas id="projectionCanvasXZ" width="400" height="400"></canvas>
    </div>
    <div class="canvas-container">
        <h4>Проекция на YZ (Вид сбоку)</h4>
        <canvas id="projectionCanvasYZ" width="400" height="400"></canvas>
    </div>
</div>

<div class="controls-matrix">
    <div class="controls">
        <div class="control-group">
            <label>Масштаб X <span id="val-sx">1</span></label><input type="range" id="scaleX" min="0.1" max="3" value="1" step="0.1">
            <label>Масштаб Y <span id="val-sy">1</span></label><input type="range" id="scaleY" min="0.1" max="3" value="1" step="0.1">
            <label>Масштаб Z <span id="val-sz">1</span></label><input type="range" id="scaleZ" min="0.1" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Вращение X (°)<span id="val-rx">20</span></label><input type="range" id="rotateX" min="-180" max="180" value="20" step="1">
            <label>Вращение Y (°)<span id="val-ry">20</span></label><input type="range" id="rotateY" min="-180" max="180" value="20" step="1">
            <label>Вращение Z (°)<span id="val-rz">0</span></label><input type="range" id="rotateZ" min="-180" max="180" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Перенос X (Локальный) <span id="val-tx">0</span></label><input type="range" id="translateX" min="-20" max="20" value="0" step="0.5">
            <label>Перенос Y (Локальный) <span id="val-ty">0</span></label><input type="range" id="translateY" min="-20" max="20" value="0" step="0.5">
            <label>Перенос Z (Локальный) <span id="val-tz">0</span></label><input type="range" id="translateZ" min="-50" max="50" value="0" step="1">
        </div>
        <button id="resetButton">Сбросить все настройки</button>
    </div>
    <div id="matrix-display"></div>
</div>

<script>
const MatrixMath = {
    multiplyMatrixAndPoint: (m, p) => {
        const v = [p.x, p.y, p.z, 1], r = [0,0,0,0];
        for(let i=0;i<4;i++) for(let j=0;j<4;j++) r[i]+=m[i][j]*v[j];
        return { x: r[0], y: r[1], z: r[2] };
    },
    multiplyMatrices: (m1, m2) => {
        const r=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
        for(let i=0;i<4;i++) for(let j=0;j<4;j++) for(let k=0;k<4;k++) r[i][j]+=m1[i][k]*m2[k][j];
        return r;
    },
    createIdentityMatrix: () => [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],
    createScaleMatrix: (sx,sy,sz) => [[sx,0,0,0],[0,sy,0,0],[0,0,sz,0],[0,0,0,1]],
    createTranslationMatrix: (tx,ty,tz) => [[1,0,0,tx],[0,1,0,ty],[0,0,1,tz],[0,0,0,1]],
    createRotationXMatrix: a => { const c=Math.cos(a),s=Math.sin(a); return [[1,0,0,0],[0,c,-s,0],[0,s,c,0],[0,0,0,1]]; },
    createRotationYMatrix: a => { const c=Math.cos(a),s=Math.sin(a); return [[c,0,s,0],[0,1,0,0],[-s,0,c,0],[0,0,0,1]]; },
    createRotationZMatrix: a => { const c=Math.cos(a),s=Math.sin(a); return [[c,-s,0,0],[s,c,0,0],[0,0,1,0],[0,0,0,1]]; }
};

class CyrillicLetterK3D {
    constructor() {
        const rawVertices = [
            [0,0,0],[3,0,0],[3,10,0],[0,10,0],[0,0,2],[3,0,2],[3,10,2],[0,10,2], 
            [3,5,0],[6,10,0],[9,10,0],[6,5,0],[3,5,2],[6,10,2],[9,10,2],[6,5,2], 
            [3,5,0],[6,0,0],[9,0,0],[6,5,0],[3,5,2],[6,0,2],[9,0,2],[6,5,2]  
        ];
        
        this.originalVertices = rawVertices.map(v => ({ x: v[0]-4.5, y: v[1]-5, z: v[2]-1 }));
        
        this.faces = [
            [0,1,2,3],[4,5,6,7],[0,1,5,4],[2,3,7,6],[0,3,7,4],[1,2,6,5],
            [8,9,10,11],[12,13,14,15],[8,9,13,12],[10,11,15,14],[8,11,15,12],[9,10,14,13],
            [16,17,18,19],[20,21,22,23],[16,17,21,20],[18,19,23,22],[16,19,23,20],[17,18,22,21],
            [2,8,12,6], [1,16,20,5]
        ];

        this.scale = {x:1,y:1,z:1}; 
        this.translate={x:0,y:0,z:0}; 
        this.rotate={x:0,y:0,z:0};
        this.currentMatrix = MatrixMath.createIdentityMatrix();
    }

    getTransformedVertices(applyRotation = true) {
        const s = this.scale, r = this.rotate, t = this.translate;
        
        const scaleM = MatrixMath.createScaleMatrix(s.x, s.y, s.z);
        const transM = MatrixMath.createTranslationMatrix(t.x, t.y, t.z);
        
        let finalM;

        if (applyRotation) {
            const rotXM = MatrixMath.createRotationXMatrix(r.x * Math.PI / 180);
            const rotYM = MatrixMath.createRotationYMatrix(r.y * Math.PI / 180);
            const rotZM = MatrixMath.createRotationZMatrix(r.z * Math.PI / 180);
            let rotM = MatrixMath.multiplyMatrices(rotYM, rotXM);
            rotM = MatrixMath.multiplyMatrices(rotZM, rotM);

            const localTransform = MatrixMath.multiplyMatrices(transM, scaleM);

            finalM = MatrixMath.multiplyMatrices(rotM, localTransform);
            
            this.currentMatrix = finalM;
        } else {
            finalM = MatrixMath.multiplyMatrices(transM, scaleM);
        }

        return this.originalVertices.map(v => MatrixMath.multiplyMatrixAndPoint(finalM, v));
    }

    getRotationMatrix() {
        const r = this.rotate;
        const rotXM = MatrixMath.createRotationXMatrix(r.x * Math.PI / 180);
        const rotYM = MatrixMath.createRotationYMatrix(r.y * Math.PI / 180);
        const rotZM = MatrixMath.createRotationZMatrix(r.z * Math.PI / 180);
        let m = MatrixMath.multiplyMatrices(rotYM, rotXM);
        return MatrixMath.multiplyMatrices(rotZM, m);
    }
}

class Visualization3D {
    constructor() {
        this.letter = new CyrillicLetterK3D();
        this.setupCanvases();
        this.setupControls();
        this.updateVisualization();
    }

    setupCanvases() {
        this.canvases = { 
            main: document.getElementById('mainCanvas'), 
            xy: document.getElementById('projectionCanvasXY'), 
            xz: document.getElementById('projectionCanvasXZ'), 
            yz: document.getElementById('projectionCanvasYZ') 
        };
        this.contexts = { 
            main: this.canvases.main.getContext('2d'), 
            xy: this.canvases.xy.getContext('2d'), 
            xz: this.canvases.xz.getContext('2d'), 
            yz: this.canvases.yz.getContext('2d') 
        };
    }

    setupControls() {
        this.sliders = { 
            scaleX:document.getElementById('scaleX'), scaleY:document.getElementById('scaleY'), scaleZ:document.getElementById('scaleZ'), 
            rotateX:document.getElementById('rotateX'), rotateY:document.getElementById('rotateY'), rotateZ:document.getElementById('rotateZ'), 
            translateX:document.getElementById('translateX'), translateY:document.getElementById('translateY'), translateZ:document.getElementById('translateZ') 
        };

        Object.keys(this.sliders).forEach(key => {
            this.sliders[key].addEventListener('input', (e) => {
                const span = document.querySelector(`#val-${key.replace('scale','s').replace('rotate','r').replace('translate','t').toLowerCase()}`);
                if(span) span.textContent = e.target.value;
                this.updateFromSliders();
            });
        });

        document.getElementById('resetButton').addEventListener('click', () => this.resetParameters());
    }

    updateFromSliders() {
        this.letter.scale = { x:parseFloat(this.sliders.scaleX.value), y:parseFloat(this.sliders.scaleY.value), z:parseFloat(this.sliders.scaleZ.value) };
        this.letter.rotate = { x:parseInt(this.sliders.rotateX.value), y:parseInt(this.sliders.rotateY.value), z:parseInt(this.sliders.rotateZ.value) };
        this.letter.translate = { x:parseFloat(this.sliders.translateX.value), y:parseFloat(this.sliders.translateY.value), z:parseFloat(this.sliders.translateZ.value) };
        this.updateVisualization();
    }

    resetParameters() {
        this.sliders.scaleX.value=1; this.sliders.scaleY.value=1; this.sliders.scaleZ.value=1;
        this.sliders.rotateX.value=20; this.sliders.rotateY.value=20; this.sliders.rotateZ.value=0;
        this.sliders.translateX.value=0; this.sliders.translateY.value=0; this.sliders.translateZ.value=0;
        
        ['sx','sy','sz','rx','ry','rz','tx','ty','tz'].forEach(k => {
             const el = document.getElementById('val-'+k);
             if(el) el.textContent = (k.startsWith('r') && k!=='rz') ? '20' : (k==='rz'||k.startsWith('t') ? '0' : '1');
        });
        this.updateFromSliders();
    }
    
    applyPerspective(point, zoom) {
        const perspective = 800; 
        const scaleFactor = perspective / (perspective - (point.z * zoom));
        return {
            x: point.x * zoom * scaleFactor,
            y: point.y * zoom * scaleFactor
        };
    }

    drawFlatAxes(ctx, label1, label2) {
        const w = ctx.canvas.width, h = ctx.canvas.height;
        const cx = w/2, cy = h/2;
        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=-200; i<=200; i+=40) {
            ctx.moveTo(cx+i, 0); ctx.lineTo(cx+i, h);
            ctx.moveTo(0, cy+i); ctx.lineTo(w, cy+i);
        }
        ctx.stroke();
        ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, cy); ctx.lineTo(w, cy);
        ctx.moveTo(cx, 0); ctx.lineTo(cx, h);
        ctx.stroke();
        ctx.fillStyle = '#ff9800'; ctx.font = 'bold 14px Arial';
        ctx.fillText(label1, w - 20, cy - 10);
        ctx.fillText(label2, cx + 10, 20);
    }
    
    draw3DAxes(ctx, zoom) {
        const w = ctx.canvas.width, h = ctx.canvas.height;
        const cx = w/2, cy = h/2;
        const axisLength = 8;
        const rotM = this.letter.getRotationMatrix();
        
        const origin = {x:0, y:0, z:0};
        const xAxis = {x:axisLength, y:0, z:0};
        const yAxis = {x:0, y:axisLength, z:0};
        const zAxis = {x:0, y:0, z:axisLength}; 

        const transform = (p) => MatrixMath.multiplyMatrixAndPoint(rotM, p);
        
        const tOrigin = transform(origin);
        const tX = transform(xAxis);
        const tY = transform(yAxis);
        const tZ = transform(zAxis);

        const drawLine = (start, end, color, label) => {
            const pStart = this.applyPerspective(start, zoom);
            const pEnd = this.applyPerspective(end, zoom);

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.moveTo(pStart.x + cx, -pStart.y + cy);
            ctx.lineTo(pEnd.x + cx, -pEnd.y + cy);
            ctx.stroke();
            
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Arial';
            ctx.fillText(label, pEnd.x + cx + 5, -pEnd.y + cy - 5);
        };

        drawLine(tOrigin, tX, '#ff4444', 'X');
        drawLine(tOrigin, tY, '#44ff44', 'Y');
        drawLine(tOrigin, tZ, '#4444ff', 'Z');
    }

    drawObject(ctx, vertices, axis1, axis2, color, zoom, is3DView = false) {
        const w = ctx.canvas.width, h = ctx.canvas.height;
        const offsetX = w / 2, offsetY = h / 2;

        ctx.strokeStyle = color; ctx.lineWidth = 2;
        
        this.letter.faces.forEach(face => {
            ctx.beginPath();
            
            const getCoords = (index) => {
                const p = vertices[index];
                if (is3DView) {
                    const proj = this.applyPerspective(p, zoom);
                    return { x: proj.x, y: proj.y };
                } else {
                    return { x: p[axis1] * zoom, y: p[axis2] * zoom };
                }
            };

            const start = getCoords(face[0]);
            ctx.moveTo(start.x + offsetX, -start.y + offsetY);
            
            for (let i = 1; i < face.length; i++) {
                const p = getCoords(face[i]);
                ctx.lineTo(p.x + offsetX, -p.y + offsetY);
            }
            ctx.closePath();
            ctx.stroke();
            
            if(is3DView) {
                 ctx.fillStyle = color + '22';
                 ctx.fill();
            }
        });
    }

    updateMatrixDisplay() {
        const matrix = this.letter.currentMatrix;
        let str = 'Итоговая матрица преобразований (Model Matrix):\n';
        matrix.forEach(row => {
            str += `| ${row.map(v => v.toFixed(3).padStart(8,' ')).join(' ')} |\n`;
        });
        document.getElementById('matrix-display').textContent = str;
    }

    updateVisualization() {
        const zoom = 15;
        const vertices3D = this.letter.getTransformedVertices(true);
        const verticesFlat = this.letter.getTransformedVertices(false);

        const ctxMain = this.contexts.main;
        ctxMain.clearRect(0, 0, 400, 400);
        this.draw3DAxes(ctxMain, zoom);
        this.drawObject(ctxMain, vertices3D, 'x', 'y', '#ffffff', zoom, true);

        const ctxXY = this.contexts.xy;
        ctxXY.clearRect(0,0,400,400);
        this.drawFlatAxes(ctxXY, 'X', 'Y');
        this.drawObject(ctxXY, verticesFlat, 'x', 'y', '#00ffff', zoom);

        const ctxXZ = this.contexts.xz;
        ctxXZ.clearRect(0,0,400,400);
        this.drawFlatAxes(ctxXZ, 'X', 'Z');
        this.drawObject(ctxXZ, verticesFlat, 'x', 'z', '#ff00ff', zoom);

        const ctxYZ = this.contexts.yz;
        ctxYZ.clearRect(0,0,400,400);
        this.drawFlatAxes(ctxYZ, 'Z', 'Y'); 
        this.drawObject(ctxYZ, verticesFlat, 'z', 'y', '#ffff00', zoom);

        this.updateMatrixDisplay();
    }
}

document.addEventListener('DOMContentLoaded', () => { new Visualization3D(); });
</script>

</body>
</html>